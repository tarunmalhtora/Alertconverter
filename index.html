<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Display</title>
</head>
<body>
    <h2>Python Code:</h2>
    <pre>
<code>
    app.py
import re
import flask
import json
from flask import Flask, request, jsonify, render_template

app = Flask(__name__, static_folder="static", template_folder="templates")

@app.route('/')
def home():
    return render_template('home.html')

@app.route('/convert', methods=['POST'])
def convert_query():
    data = request.json
    spl_query = data.get("spl_query", "")

    if not spl_query:
        return jsonify({"error": "No SPL query provided"}), 400

    print(f"Received SPL Query: {spl_query}")

    Returned_list_output = clean_spl_query(spl_query)
    
    final_opensearch_query = Returned_list_output[1] #dict
    index_name = Returned_list_output[0] #string
    DSL_header = f"POST /{index_name}/_search\n" 

    print("opensearch_query -->",final_opensearch_query,type(final_opensearch_query))
    print("index_name extracted",index_name,type(index_name))
    print("DSL_header extracted",DSL_header,type(DSL_header))

    # Extract and remove index_name before returning
    index_name = final_opensearch_query.pop("index_name", "default-index")
    print("index_name lates",index_name,type(index_name))


    super_final_query_string = DSL_header.strip() + "\n" + json.dumps(final_opensearch_query, indent=2)

    print("super_final_query_string",super_final_query_string,type(super_final_query_string))


    # print("final_output-zzzz",super_final_query_string,type(super_final_query_string))
    # print("Final Output:\n", json.dumps(super_final_query_string, indent=2))

    return jsonify(super_final_query_string)
    #print("sdfsfsdfs",jsonify(final_output))

def clean_spl_query(spl_query):
    spl_query = re.sub(r'\s*=\s*', '=', spl_query)
    first_phase_query = spl_query.split("|")[0].strip()
    return parse_stats_clause(spl_query, first_phase_query)

def parse_stats_clause(spl_query, first_phase_query):
    metric_clauses = []
    by_clause_fields = []

    stats_match = re.search(r'\|\s*stats\s*([^|]+)', spl_query, re.IGNORECASE)
    if stats_match:
        stats_part = stats_match.group(1).strip()

        # ✅ Extract multiple functions + aliasing
        metrics = re.findall(r'(\w+)\(([\w.]+)?\)\s*(?:as\s+(\w+))?', stats_part, re.IGNORECASE)
        for func, field, alias in metrics:
            metric_clauses.append({
                "function": func,
                "field": field if field else "_id",
                "alias": alias if alias else func
            })

        # ✅ Handle standalone functions like `count as total`
        standalone_metrics = re.findall(r'\b(\w+)\s*(?:as\s+(\w+))?', stats_part)
        for func, alias in standalone_metrics:
            if func not in [m["function"] for m in metric_clauses]:
                metric_clauses.append({
                    "function": func,
                    "field": "_id",
                    "alias": alias if alias else func
                })

        # ✅ Handle multiple `by` fields (comma + space separated)
        by_match = re.search(r'\bby\s+(.+)', stats_part)
        if by_match:
            # Split by ',' or whitespace
            by_clause_fields = re.split(r'\s*,\s*|\s+', by_match.group(1).strip())

    return convert_spl_to_opensearch_complex(spl_query, first_phase_query, metric_clauses, by_clause_fields)

def convert_spl_to_opensearch_complex(spl_query, first_phase_query, metric_clauses, by_clause_fields):
    key = []  
    values = []
    
    # ✅ Extract key-value pairs from the first phase query
    field_value_pattern = re.findall(r'(\S+)\s*=\s*(?:"([^"]+)"|\'([^\']+)\'|(\S+))', first_phase_query)
    
    for field, value1, value2, value3 in field_value_pattern:
        final_value = value1 or value2 or value3
        key.append(field)
        values.append(final_value)

    Dic_Mandatory_Fields = dict(zip(key, values))
    index_name = Dic_Mandatory_Fields.get("index", "default-index")
    
    # ✅ Build the filter clause (EXCLUDING index)
    additional_fields = []
    for k, v in Dic_Mandatory_Fields.items():
        if k != "index":
            if '*' in v:
                additional_fields.append({"wildcard": {k: v}})
            else:
                additional_fields.append({"term": {k: v}})

    opensearch_query = {
        "size": 0,
        "query": {
            "bool": {
                "must": additional_fields
            }
        },
        "aggs": {}
    }

    if metric_clauses:
        if by_clause_fields:
            # ✅ Handle nested `by` fields
            current = opensearch_query["aggs"]
            for field in by_clause_fields:
                current[field] = {
                    "terms": {
                        "field": field
                    },
                    "aggs": {}
                }
                current = current[field]["aggs"]

            for metric in metric_clauses:
                function = metric["function"].lower()
                field = metric["field"]
                alias = metric["alias"]

                if function == "count":
                    current[alias] = {"value_count": {"field": field}}
                elif function in ["max", "min", "avg", "sum"]:
                    current[alias] = {function: {"field": field}}
                elif function == "percentile":
                    current[alias] = {"percentiles": {"field": field}}
                elif function == "median":
                    current[alias] = {"percentiles": {"field": field, "percents": [50]}}
                elif function == "dc":
                    current[alias] = {"cardinality": {"field": field}}
        else:
            # ✅ If no `by` clause, apply functions at the top level
            for metric in metric_clauses:
                function = metric["function"].lower()
                field = metric["field"]
                alias = metric["alias"]

                if function == "count":
                    opensearch_query["aggs"][alias] = {"value_count": {"field": field}}
                elif function in ["max", "min", "avg", "sum"]:
                    opensearch_query["aggs"][alias] = {function: {"field": field}}
                elif function == "percentile":
                    opensearch_query["aggs"][alias] = {"percentiles": {"field": field}}
                elif function == "median":
                    opensearch_query["aggs"][alias] = {"percentiles": {"field": field, "percents": [50]}}
                elif "perc" in function:
                    opensearch_query["aggs"][alias] = {"percentiles": {"field": field, "percents": [90]}}    
                elif function == "dc":
                    opensearch_query["aggs"][alias] = {"cardinality": {"field": field}}
    print("opensearch_query -> sele",opensearch_query)
    dic_up = []
    dic_up = [index_name,opensearch_query]
    print("dic_up",type(dic_up))              
    #return opensearch_query
    return dic_up
    
if __name__ == '__main__':
    app.run(debug=True)

    #############################################################################################
home.html
    <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPL to OpenSearch Converter</title>
    <link rel="stylesheet" href="static/styles.css">
    <script src="static/scripts.js" defer></script>
</head>
<body>
    <div class="container">
        <h1>SPL to OpenSearch Query DSL Converter</h1>
        <textarea id="splQuery" placeholder="Enter SPL query here..."></textarea>
        <button id="convertBtn" onclick="convertQuery()">Convert</button>
        <h2>Converted OpenSearch Query:</h2>
        <pre id="result"></pre>
        <button id="copyBtn" onclick="copyToClipboard()">Copy to Clipboard</button>
    </div>    
</body>
</html>

    ###################################################################################

    scripts.js

    function convertQuery() {
    let splQuery = document.getElementById("splQuery").value;

    fetch("/convert", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({ spl_query: splQuery })
    })
    .then(response => {
        // Check if the response is JSON or a plain string
        if (response.headers.get("Content-Type") === "application/json") {
            return response.json();
        } else {
            return response.text();
        }
    })
    .then(data => {
        if (typeof data === "string") {
            document.getElementById("result").textContent = data;
        } else {
            document.getElementById("result").textContent = JSON.stringify(data, null, 4);
        }
    })
    .catch(error => console.error("Error:", error));
}
    #############################################################################################################################
    styles.css

    body {
    font-family: Arial, sans-serif;
    text-align: center;
    background-color: #f4f4f4;
    padding: 20px;
}

.container {
    max-width: 600px;
    background: white;
    padding: 20px;
    margin: auto;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

textarea {
    width: 100%;
    height: 100px;
    margin: 10px 0;
    padding: 10px;
}

pre {
    background: #282c34;
    color: #61dafb;
    padding: 10px;
    text-align: left;
    border-radius: 5px;
    overflow-x: auto;
}

button {
    padding: 10px 20px;
    background: #007bff;
    color: white;
    border: none;
    cursor: pointer;
    margin-top: 10px;
}

button:hover {
    background: #0056b3;
}


    
</code>
    </pre>
</body>
</html>
